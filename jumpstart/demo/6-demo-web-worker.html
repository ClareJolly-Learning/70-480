<!DOCTYPE html>
<html>
<head>
<style>
.webworker section[role=main] > * {
    margin: 20px 0px;

}
</style>
</head>
<body>
    <div class="webworker fragment">
        <header aria-label="Header content" role="banner">
            <h1 class="titlearea win-type-ellipsis">
                <span class="pagetitle">Web Worker</span>
            </h1>
        </header>
        <section aria-label="Main content" role="main">
            <div class="explanation">The following text is generated by an interaction between two threads in JavaScript. Look at the code to see how these entities communicate.</div>
            <div id="log"></div>
            <div><img src="images/diagram.png" /></div>
        </section>
    </div>
<script>
function worker_function() {
    // all code here
     //this is how the main thread talks to us (the web worker)
 self.onmessage = function (e) {
  //here's how we talk to the main thread
  self.postMessage("\"Hey, boss. I heard you say '" + e.data + "\"");
};
}
// This is in case of normal worker start
// "window" is not defined in web worker
// so if you load this file directly using `new Worker`
// the worker code will still execute properly
if(window!=self)
  worker_function();

//first we create a web worker and define the js file that defines it
// var worker = new Worker("./webworker/task.js");
// Chrome doesn't like running the above when running locally so found a workaround

var worker = new Worker(URL.createObjectURL(new Blob(["("+worker_function.toString()+")()"], {type: 'text/javascript'})));

function log(text) {
    document.querySelector("#log").innerHTML = document.querySelector("#log").innerHTML + '\n' + text
}


//this is how the web worker talks to us (the main thread)
worker.onmessage = function(e) {
    log("The worker said " + e.data);
};

//and this is how we talk to the web worker
worker.postMessage("Hey there, worker.");
</script>
</body>
</html>
